# facerecognationexamsessions

```PROMPT_FOR_COPILOT
Создай полнофункциональное веб-приложение на Python + Flask для распознавания лиц студентов и массовой загрузки базы из Excel. Требования и поведение приложения — строгое техническое задание:

1) Окружение и зависимости
- Python 3.10+
- Библиотеки: Flask, SQLAlchemy, pandas, openpyxl, face_recognition, opencv-python, numpy, scikit-learn (neighbors), Flask-Uploads (или простая загрузка), XlsxWriter (для экспорта отчёта).
- Всё должно устанавливаться через `requirements.txt`.

2) Структура проекта (сгенерируй файлы и папки)


project/
├── app.py                     # точка входа Flask
├── models.py                  # SQLAlchemy модели
├── db.py                      # инициализация базы
├── face\_utils.py              # функции работы с изображениями/эмбеддингами
├── loader.py                  # скрипт/endpoint массовой загрузки из Excel
├── templates/
│   └── index.html             # фронтенд (камера, upload)
├── static/
│   └── js/main.js
├── data/
│   └── embeddings.npy         # (опционально) кеш эмбеддингов
├── database.db                # SQLite (по умолчанию)
├── "Face ID docs"/
│   ├── list of students.xlsx  # исходный Excel
│   └── photos/                # папка с фотографиями (пути в Excel)
└── requirements.txt



3) Описание Excel и массовой загрузки
- Ожидаемый Excel: `Face ID docs/list of students.xlsx` с колонками (точно):  
  `Matricula, Lastname, Firstname, Lotin, Short, Group, Идентификатор, Date of birth, Passport number, File path`
- Реализуй CLI-скрипт и HTTP-endpoint `/admin/load_excel` (POST, защищённый простым токеном в конфиге) который:
  - читает Excel с помощью pandas,
  - для каждой строки ищет файл картинки по относительному/абсолютному пути из `File path` (если путь абсолютный — использовать его; если путь относительный — относить к корню проекта / "Face ID docs/photos"),
  - извлекает эмбеддинг лица через `face_recognition.face_encodings()` (если на фото >1 лица — брать первое, но логировать предупреждение),
  - если на фото лицо не найдено — логировать и пропускать запись (не добавлять в БД),
  - сохраняет в БД: все поля метаданных + эмбеддинг (как BLOB или как отдельный numpy-файл и ссылку).
- Скрипт должен пропускать уже существующие записи (по `Matricula` или `Идентификатор`) и иметь опцию `--force` для перезаписи.

4) Хранение эмбеддингов и оптимизация поиска
- При старте приложения (или при загрузке базы) заранее подтягивать все эмбеддинги в память в numpy array размером (N,128).
- Для быстрого поиска используй `sklearn.neighbors.NearestNeighbors` с `algorithm='auto'` и `metric='euclidean'` или векторный брутфорс через numpy (для 2500 записей b2-b рекоммендация: простой векторный поиск будет очень быстрым).
- **Критерий совпадения**: использовать косинусную схожесть или евклидову дистанцию по эмбеддингу. Настройка порога должна быть параметром конфигурации:  
  - Рекомендация по умолчанию: `threshold = 0.5` (cosine distance) или `0.45` (face_recognition default ~0.6 — слишком слабый; делаем более строгий).  
  - Обязательно: **НЕ** возвращать "похожие" лица, если лучшая дистанция выше порога — в этом случае возвращать явное `"Лицо не найдено"`.
- Обеспечь функцию `rebuild_index()` для пересоздания кеша/индекса после массовой загрузки.

5) API для распознавания и фронтенд
- Endpoint `POST /api/recognize`:
  - Принимает изображение (multipart/form-data) или Base64.
  - На входе: извлечь эмбеддинг(и) из отправленного кадра; если найдено >1 лиц — вернуть ошибку "найдено несколько лиц" (или использовать первый — но требование: предупреждать).
  - Сравнить эмбеддинг с кешем, найти ближайший (или n_neighbors=1). Если расстояние <= threshold — считать найденным и вернуть JSON с полными данными студента. Иначе — вернуть `{"status":"not_found"}`.
  - При успешной идентификации: логируем проход в таблицу `passes` с полями `id, student_id, timestamp, source` (camera/web).
- Фронтенд `index.html`:
  - Кнопка «Открыть камеру», предпросмотр, кнопка «Сделать фото» → отправка на `/api/recognize`.
  - Показывать результат: данные студента или сообщение "Лицо не найдено".
  - Если студент уже проходил сегодня — показать: "Студент уже проходил сегодня" + время первого прохода.

6) Проверка повторных проходов
- Таблица `passes` записывает каждый проход.
- При распознавании проверять: есть ли запись для этого `student_id` где `date(timestamp) == today`.  
  - Если есть — вернуть статус `already_passed` и данные первой записи за сегодня.
  - Если нет — создать новую запись и вернуть `ok`.

7) Экспорт отчёта
- Endpoint `/admin/export_report` (GET, защищённый токеном) — генерирует Excel-файл отчёта с колонками: `Matricula, Lastname, Firstname, Group, Идентификатор, DateTime of pass, Passport number` и т.д.  
- Сформировать файл через XlsxWriter и вернуть как скачивание.

8) Логирование и обработка ошибок
- Логировать все ошибки загрузки изображений, строки Excel с пропущенными/повреждёнными данными.
- При загрузке из Excel формировать summary report: сколько записей добавлено, сколько пропущено (и почему).

9) Безопасность и конфигурация
- Хранить порог сходства, токен администратора, путь к `Face ID docs` в конфиге (`config.py`).
- По умолчанию использовать SQLite, но абстрагировать через SQLAlchemy.

10) Тестирование и нагрузка
- Добавь простой скрипт `benchmarks/test_lookup.py`, который прогоняет 2500 случайных сравнений (генерировать рандомные эмбеддинги или использовать реальные) и выводит среднее время поиска одного запроса. Цель: < 100 ms на поиск для 2500 записей на обычном CPU — если больше, предложить альтернативу FAISS/Annoy и показать пример интеграции.

11) Критерии приёмки
- Скрипт массовой загрузки корректно инжектит ~2500 студентов (если есть фото и корректный Excel).
- Распознавание не возвращает похожих кандидатов, только точный матч при условии, что distance <= threshold.
- Повторный проход на ту же дату определяется и возвращается как `already_passed`.
- Экспорт отчёта корректно скачивается в Excel.

12) Комментарии в коде и README
- Сгенерируй README с инструкцией: как подготовить `Face ID docs`, как запустить `loader.py`, как поднять сервер и как изменить пороги.

Дополнительно: если реализация использует FAISS/Annoy — сделай это опциональным, с инструкцией как установить (pip) и переключить в конфиге.

--- Конец промпта ---
```

